// Google Earth Engine Service Module for Heat Island Analysis
// Handles all interactions with Google Earth Engine API for heat data
const ee = require('@google/earthengine');
const path = require('path');

class GEEService {
  constructor() {
    this.isInitialized = false;
  }

  /**
   * Initialize Google Earth Engine with service account
   * This must be called before any other GEE operations
   */
  async initialize() {
    if (this.isInitialized) {
      return Promise.resolve();
    }

    return new Promise((resolve, reject) => {
      try {
        // Path to service account JSON file
        const serviceAccountPath = process.env.GEE_SERVICE_ACCOUNT_PATH || './config/gee-service-account.json';
        
        if (!require('fs').existsSync(serviceAccountPath)) {
          throw new Error(`GEE service account file not found at: ${serviceAccountPath}`);
        }

        const serviceAccount = require(path.resolve(serviceAccountPath));
        
        ee.data.authenticateViaPrivateKey(
          serviceAccount,
          () => {
            ee.initialize(
              null,
              null,
              () => {
                console.log('‚úÖ Google Earth Engine initialized successfully');
                this.isInitialized = true;
                resolve();
              },
              (error) => {
                console.error('‚ùå Failed to initialize Google Earth Engine:', error);
                reject(error);
              }
            );
          },
          (error) => {
            console.error('‚ùå Failed to authenticate with Google Earth Engine:', error);
            reject(error);
          }
        );
      } catch (error) {
        console.error('‚ùå GEE Service initialization error:', error);
        reject(error);
      }
    });
  }

  /**
   * Fetch Land Surface Temperature data from Landsat for heat island analysis
   * @param {Object} bounds - Bounding box coordinates {north, south, east, west}
   * @param {string} startDate - Start date in YYYY-MM-DD format
   * @param {string} endDate - End date in YYYY-MM-DD format
   * @returns {Promise<Object>} - GEE image data with download URL
   */
  async getHeatIslandData(bounds, startDate = '2024-01-01', endDate = '2024-08-01') {
    await this.initialize();

    try {
      console.log('üõ∞Ô∏è Processing Landsat LST data with Google Earth Engine...');
      
      // --- AOI (Area of Interest) ---
      const geometry = ee.Geometry.Rectangle([bounds.west, bounds.south, bounds.east, bounds.north]);

      // --- Helper Functions ---
      const inHotMonths = ee.Filter.calendarRange(4, 6, 'month'); // Apr‚ÄìJun for best heat data
      
      // QA_PIXEL bits (L2): 3 = cloud shadow, 4 = snow/ice, 5 = cloud, 7 = cirrus
      const maskLandsatQA = (img) => {
        const qa = img.select('QA_PIXEL');
        const cloudShadow = qa.bitwiseAnd(1 << 3).eq(0);
        const snowIce     = qa.bitwiseAnd(1 << 4).eq(0);
        const cloud       = qa.bitwiseAnd(1 << 5).eq(0);
        const cirrus      = qa.bitwiseAnd(1 << 7).eq(0);
        return img.updateMask(cloudShadow.and(snowIce).and(cloud).and(cirrus));
      };
      
      // Convert Landsat thermal band to Celsius
      const toCelsiusL8 = (img) => {
        const lstC = img.select('ST_B10').multiply(0.00341802).add(149.0).subtract(273.15).rename('LST');
        return img.addBands(lstC, null, true).copyProperties(img, ['system:time_start']);
      };

      // --- Landsat 8/9 Collection 2 Level 2 (merge collections) ---
      const l8 = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')
          .filterBounds(geometry)
          .filterDate(startDate, endDate)
          .filter(ee.Filter.lt('CLOUD_COVER', 20))
          .select(['ST_B10','QA_PIXEL'])
          .map(maskLandsatQA)
          .map(toCelsiusL8);
          
      const l9 = ee.ImageCollection('LANDSAT/LC09/C02/T1_L2')
          .filterBounds(geometry)
          .filterDate(startDate, endDate)
          .filter(ee.Filter.lt('CLOUD_COVER', 20))
          .select(['ST_B10','QA_PIXEL'])
          .map(maskLandsatQA)
          .map(toCelsiusL8);
          
      const landsat = l8.merge(l9);

      // Check if collection has data
      const collectionSize = await new Promise((resolve, reject) => {
        landsat.filter(inHotMonths).size().getInfo((size, error) => {
          if (error) reject(error);
          else resolve(size);
        });
      });

      if (collectionSize === 0) {
        throw new Error('No data available for the specified area and time period');
      }

      console.log(`üìä Found ${collectionSize} quality Landsat images for processing`);

      // --- Hot-season composite (Apr‚ÄìJun median) ---
      const hotComposite = landsat.filter(inHotMonths).median().clip(geometry);

      // --- Land cover classification for urban/rural analysis ---
      const lc = ee.ImageCollection('MODIS/006/MCD12Q1')
          .filterDate('2020-01-01','2020-12-31')
          .first()
          .select('LC_Type1');
      const urbanMask = lc.eq(13); // Urban and built-up lands
      const ruralMask = lc.neq(13).and(lc.neq(17)); // Exclude urban and water

      // --- Calculate Urban/Rural mean temperatures ---
      const reduceCfg = { 
        reducer: ee.Reducer.mean(), 
        geometry, 
        scale: 30, 
        maxPixels: 1e9 
      };
      
      const urbanMeanResult = await new Promise((resolve, reject) => {
        hotComposite.select('LST').updateMask(urbanMask).reduceRegion(reduceCfg).getInfo((result, error) => {
          if (error) reject(error);
          else resolve(result.LST || null);
        });
      });
      
      const ruralMeanResult = await new Promise((resolve, reject) => {
        hotComposite.select('LST').updateMask(ruralMask).reduceRegion(reduceCfg).getInfo((result, error) => {
          if (error) reject(error);
          else resolve(result.LST || null);
        });
      });

      // --- Create heat intensity zones ---
      const LST = hotComposite.select('LST');
      const heatZones = LST
        .where(LST.lt(30), 1)       // Cool zones
        .where(LST.gte(30).and(LST.lt(35)), 2)  // Moderate zones
        .where(LST.gte(35).and(LST.lt(40)), 3)  // Hot zones
        .where(LST.gte(40), 4)      // Extreme heat zones
        .rename('HeatZones');

      // --- Visualization parameters ---
      const lstVis = { 
        min: 25, 
        max: 45, 
        palette: ['blue','cyan','green','yellow','orange','red'] 
      };
      
      const zoneVis = { 
        min: 1, 
        max: 4, 
        palette: ['blue','green','yellow','red'] 
      };

      // --- Generate image thumbnail URL ---
      // Determine dimensions based on area size (larger areas get higher resolution)
      const areaDeg2 = (bounds.east - bounds.west) * (bounds.north - bounds.south);
      const dimensions = areaDeg2 > 1 ? 1024 : 512;

      const imageUrl = await new Promise((resolve, reject) => {
        LST.getThumbURL(
          { 
            ...lstVis, 
            region: geometry, 
            format: 'png', 
            dimensions 
          },
          (url, err) => {
            if (err) {
              reject(new Error(`Failed to generate image: ${err}`));
            } else {
              resolve(url);
            }
          }
        );
      });

      // --- Calculate temperature statistics ---
      const temperatureStats = await new Promise((resolve) => {
        LST.reduceRegion({
          reducer: ee.Reducer.percentile([10, 25, 50, 75, 90]).combine(
            ee.Reducer.minMax(), '', true
          ).combine(
            ee.Reducer.mean(), '', true
          ),
          geometry, 
          scale: 30, 
          maxPixels: 1e9
        }).getInfo((result) => {
          resolve(result || {});
        });
      });

      // --- Calculate heat island intensity ---
      const heatIslandIntensity = urbanMeanResult && ruralMeanResult ? 
        (urbanMeanResult - ruralMeanResult).toFixed(2) : null;

      // Skip time series computation for streamlined response - only process selected year data
      console.log('‚úÖ Processing complete for selected year range only');

      return {
        success: true,
        imageUrl,
        bounds,
        dateRange: { start: startDate, end: endDate },
        dataSource: 'LANDSAT/LC08, LC09 Collection 2 Level 2 (ST_B10) + MODIS MCD12Q1',
        description: 'Hot-season (Apr‚ÄìJun) Land Surface Temperature median composite with urban heat island analysis',
        visualizationParams: lstVis,
        statistics: {
          imageCount: collectionSize,
          temperatureStats,
          urbanMeanC: urbanMeanResult ? parseFloat(urbanMeanResult.toFixed(2)) : null,
          ruralMeanC: ruralMeanResult ? parseFloat(ruralMeanResult.toFixed(2)) : null,
          heatIslandIntensity: heatIslandIntensity ? parseFloat(heatIslandIntensity) : null,
          temperatureRange: { min: 25, max: 45 }
        },
        processingInfo: {
          algorithm: 'Median composite of quality-filtered Landsat thermal observations',
          units: 'Degrees Celsius',
          resolution: '30m spatial resolution',
          cloudFiltering: 'QA_PIXEL quality flags applied (<20% cloud cover)',
          temporalFilter: 'Hot season months (April-June) for maximum heat signal'
        },
        heatZones: {
          description: 'Temperature-based heat intensity classification',
          zones: {
            1: 'Cool (<30¬∞C)',
            2: 'Moderate (30-35¬∞C)', 
            3: 'Hot (35-40¬∞C)',
            4: 'Extreme (>40¬∞C)'
          },
          visualizationParams: zoneVis
        }
      };

    } catch (error) {
      console.error('‚ùå Error fetching heat island data:', error);
      
      if (error.message.includes('User memory limit exceeded')) {
        throw new Error('Area too large for processing. Please try a smaller region.');
      } else if (error.message.includes('Computation timed out')) {
        throw new Error('Processing timed out. Please try a smaller area or different time period.');
      } else if (error.message.includes('No data available')) {
        throw new Error('No satellite data available for the specified area and time period.');
      } else {
        throw new Error(`Failed to process heat island data: ${error.message}`);
      }
    }
  }

  /**
   * Get heat island data for predefined city bounds
   * @param {string} cityName - Name of the city
   * @param {string} startDate - Start date in YYYY-MM-DD format
   * @param {string} endDate - End date in YYYY-MM-DD format
   * @returns {Promise<Object>} - Heat island data for the city
   */
  async getCityHeatData(cityName, startDate, endDate) {
    const cityBounds = this.getCityBounds(cityName);
    if (!cityBounds) {
      throw new Error(`City "${cityName}" not found or not supported`);
    }

    return await this.getHeatIslandData(cityBounds, startDate, endDate);
  }

  /**
   * Get predefined bounds for major cities
   * @param {string} cityName - Name of the city
   * @returns {Object|null} - Bounding box coordinates or null if not found
   */
  getCityBounds(cityName) {
    const cityBounds = {
      'New York': { north: 40.9176, south: 40.4774, east: -73.7004, west: -74.2591 },
      'Los Angeles': { north: 34.3373, south: 33.7037, east: -118.1553, west: -118.6681 },
      'Chicago': { north: 42.0126, south: 41.6445, east: -87.5246, west: -87.9073 },
      'Houston': { north: 30.1097, south: 29.5243, east: -95.0139, west: -95.8236 },
      'Phoenix': { north: 33.6816, south: 33.2948, east: -111.9439, west: -112.3250 },
      'Philadelphia': { north: 40.1379, south: 39.8670, east: -74.9559, west: -75.2803 }
    };

    return cityBounds[cityName] || null;
  }

    /**
   * Fetch Population Density data from NASA SEDAC GPW for demographic analysis (streamlined)
   * @param {Object} bounds - Bounding box coordinates {north, south, east, west}
   * @param {number} year - Year for population data (2000, 2005, 2010, 2015, 2020, 2025)
   * @returns {Promise<Object>} - GEE image data with download URL for selected year only
   */
  async getPopulationData(bounds, year = 2020) {
    await this.initialize();

    try {
      console.log(`üë• Processing population data for selected year ${year} with Google Earth Engine...`);
      
      // --- AOI (Area of Interest) ---
      const geometry = ee.Geometry.Rectangle([bounds.west, bounds.south, bounds.east, bounds.north]);

      // --- NASA SEDAC Gridded Population of World (GPW) v4.11 ---
      const populationCollection = ee.ImageCollection('CIESIN/GPWv411/GPW_Population_Density');
      
      // Filter by selected year only
      const startYear = year.toString() + '-01-01';
      const endYear = year.toString() + '-12-31';
      
      const populationDensity = populationCollection
        .filterDate(startYear, endYear)
        .first()
        .select('population_density')
        .clip(geometry);

      // Check if data exists for the selected year
      const imageInfo = await new Promise((resolve, reject) => {
        populationDensity.getInfo((info, error) => {
          if (error) {
            reject(error);
          } else if (!info) {
            reject(new Error(`No population data available for selected year ${year}`));
          } else {
            resolve(info);
          }
        });
      });

      console.log(`üìä Processing population density data for selected year ${year}`);

      // --- Visualization parameters ---
      const popVis = { 
        min: 0, 
        max: 1000, 
        palette: ['lightblue', 'yellow', 'orange', 'red', 'darkred'] 
      };

      // --- Generate image thumbnail URL ---
      const areaDeg2 = (bounds.east - bounds.west) * (bounds.north - bounds.south);
      const dimensions = areaDeg2 > 1 ? 1024 : 512;

      const imageUrl = await new Promise((resolve, reject) => {
        populationDensity.getThumbURL(
          { 
            ...popVis, 
            region: geometry, 
            format: 'png', 
            dimensions 
          },
          (url, err) => {
            if (err) {
              reject(new Error(`Failed to generate population image: ${err}`));
            } else {
              console.log('‚úÖ Generated population image URL for selected year');
              resolve(url);
            }
          }
        );
      });

      // --- Calculate population statistics ---
      console.log(`üìä Computing population statistics for year ${year}`);
      
      const populationStats = await new Promise((resolve) => {
        populationDensity.reduceRegion({
          reducer: ee.Reducer.mean().combine(
            ee.Reducer.minMax(), '', true
          ).combine(
            ee.Reducer.sum(), '', true
          ).combine(
            ee.Reducer.stdDev(), '', true
          ),
          geometry, 
          scale: 1000, // 1km resolution for population data
          maxPixels: 1e9
        }).getInfo((result) => {
          resolve(result || {});
        });
      });

      // Calculate area for population estimates
      const areaKm2 = await new Promise((resolve) => {
        geometry.area().getInfo((result) => {
          resolve((result || 0) / 1e6); // Convert from m¬≤ to km¬≤
        });
      });

      // Extract statistics
      const meanDensity = populationStats.population_density_mean || 0;
      const minDensity = populationStats.population_density_min || 0;
      const maxDensity = populationStats.population_density_max || 0;
      const totalPopulation = populationStats.population_density_sum || 0;
      const stdDensity = populationStats.population_density_stdDev || 0;

      // Enhanced response with comprehensive statistics
      console.log('‚úÖ Population processing complete for selected year with statistics');

      return {
        success: true,
        imageUrl,
        bounds,
        year,
        dataSource: 'NASA SEDAC Gridded Population of the World (GPW) v4.11',
        description: `Population density estimates for selected year ${year}`,
        visualizationParams: popVis,
        statistics: {
          estimatedTotalPopulation: Math.round(totalPopulation),
          urbanMeanDensity: Math.round(meanDensity * 100) / 100,
          ruralMeanDensity: Math.round(minDensity * 100) / 100, // Using min as rural approximation
          populationStats: {
            mean: Math.round(meanDensity * 100) / 100,
            min: Math.round(minDensity * 100) / 100,
            max: Math.round(maxDensity * 100) / 100,
            standardDeviation: Math.round(stdDensity * 100) / 100,
            totalPopulation: Math.round(totalPopulation),
            totalAreaKm2: Math.round(areaKm2 * 100) / 100
          },
          densityRange: { min: minDensity, max: maxDensity },
          totalAreaKm2: Math.round(areaKm2 * 100) / 100
        },
        metadata: {
          algorithm: 'UN-adjusted population estimates from national census data',
          units: 'People per square kilometer',
          resolution: '30 arc-seconds (~1km at equator)',
          dataYear: year,
          source: 'Center for International Earth Science Information Network (CIESIN)',
          processingInfo: {
            imageCount: 1,
            qualityScore: 'High - Census-based estimates',
            coverage: 'Global'
          }
        }
      };

    } catch (error) {
      console.error('‚ùå Error fetching population data:', error);
      
      if (error.message.includes('User memory limit exceeded')) {
        throw new Error('Area too large for processing. Please try a smaller region.');
      } else if (error.message.includes('Computation timed out')) {
        throw new Error('Processing timed out. Please try a smaller area.');
      } else if (error.message.includes('No population data available')) {
        throw new Error(`No population data available for year ${year}. Available years: 2000, 2005, 2010, 2015, 2020.`);
      } else {
        throw new Error(`Population data processing failed: ${error.message}`);
      }
    }
  }

  /**
   * Get population data for predefined city bounds
   * @param {string} cityName - Name of the city
   * @param {number} year - Year for population data
   * @returns {Promise<Object>} - Population data for the city
   */
  async getCityPopulationData(cityName, year = 2020) {
    const cityBounds = this.getCityBounds(cityName);
    if (!cityBounds) {
      throw new Error(`City "${cityName}" not found or not supported`);
    }

    return await this.getPopulationData(cityBounds, year);
  }

  /**
   * Compute yearly time series of AOI mean Land Surface Temperature
   * @param {Object} geometry - AOI geometry
   * @param {string} startDate - Start date in YYYY-MM-DD format
   * @param {string} endDate - End date in YYYY-MM-DD format
   * @param {Function} maskLandsatQA - QA masking function
   * @param {Function} toCelsiusL8 - Temperature conversion function
   * @param {Object} inHotMonths - Hot season filter
   * @returns {Promise<Array>} - Array of yearly temperature points
   */
  async computeYearlyTimeSeries(geometry, startDate, endDate, maskLandsatQA, toCelsiusL8, inHotMonths) {
    try {
      // Determine the year range for time series
      const endYear = parseInt(endDate.split('-')[0]);
      const startYear = 2013; // Earliest Landsat 8 data
      
      console.log(`üìà Computing time series from ${startYear} to ${endYear}`);
      
      const timeSeries = [];
      
      // Process each year individually
      for (let year = startYear; year <= endYear; year++) {
        console.log(`üìÖ Processing year ${year}...`);
        
        try {
          // Create year-specific date range (hot season: April-June)
          const yearStart = `${year}-01-01`;
          const yearEnd = `${year}-12-31`;
          
          // --- Landsat 8/9 Collection 2 Level 2 (merge collections) ---
          const l8 = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2')
              .filterBounds(geometry)
              .filterDate(yearStart, yearEnd)
              .filter(ee.Filter.lt('CLOUD_COVER', 20))
              .select(['ST_B10','QA_PIXEL'])
              .map(maskLandsatQA)
              .map(toCelsiusL8);
              
          const l9 = ee.ImageCollection('LANDSAT/LC09/C02/T1_L2')
              .filterBounds(geometry)
              .filterDate(yearStart, yearEnd)
              .filter(ee.Filter.lt('CLOUD_COVER', 20))
              .select(['ST_B10','QA_PIXEL'])
              .map(maskLandsatQA)
              .map(toCelsiusL8);
              
          const yearLandsat = l8.merge(l9);
          
          // Filter to hot season (same as main analysis)
          const hotSeasonCollection = yearLandsat.filter(inHotMonths);
          
          // Check if there's any data for this year
          const yearCollectionSize = await new Promise((resolve, reject) => {
            hotSeasonCollection.size().getInfo((size, error) => {
              if (error) reject(error);
              else resolve(size);
            });
          });
          
          if (yearCollectionSize === 0) {
            // No data available for this year
            timeSeries.push({
              year: year,
              meanC: null,
              sampleCount: 0,
              hasData: false
            });
            console.log(`‚ùå No data available for year ${year}`);
            continue;
          }
          
          // Create hot season composite for this year
          const yearHotComposite = hotSeasonCollection.median().clip(geometry);
          
          // Calculate AOI mean temperature
          const yearMeanResult = await new Promise((resolve, reject) => {
            yearHotComposite.select('LST').reduceRegion({
              reducer: ee.Reducer.mean(),
              geometry: geometry,
              scale: 30,
              maxPixels: 1e9
            }).getInfo((result, error) => {
              if (error) reject(error);
              else resolve(result.LST || null);
            });
          });
          
          if (yearMeanResult !== null && !isNaN(yearMeanResult)) {
            timeSeries.push({
              year: year,
              meanC: parseFloat(yearMeanResult.toFixed(2)),
              sampleCount: yearCollectionSize,
              hasData: true
            });
            console.log(`‚úÖ Year ${year}: ${yearMeanResult.toFixed(2)}¬∞C (${yearCollectionSize} images)`);
          } else {
            // Data exists but computation failed (e.g., all masked pixels)
            timeSeries.push({
              year: year,
              meanC: null,
              sampleCount: yearCollectionSize,
              hasData: false
            });
            console.log(`‚ö†Ô∏è Year ${year}: No valid pixels after masking`);
          }
          
        } catch (yearError) {
          console.warn(`‚ö†Ô∏è Error processing year ${year}:`, yearError.message);
          // Add null entry for failed year
          timeSeries.push({
            year: year,
            meanC: null,
            sampleCount: 0,
            hasData: false
          });
        }
      }
      
      console.log(`üìà Time series computation complete: ${timeSeries.filter(p => p.hasData).length}/${timeSeries.length} years with data`);
      return timeSeries;
      
    } catch (error) {
      console.error('‚ùå Error computing time series:', error);
      // Return empty array on failure to not break main response
      return [];
    }
  }

  /**
   * Compute yearly time series for population density data
   * @param {Object} geometry - AOI geometry
   * @param {number} baseYear - Base year for the analysis
   * @returns {Promise<Array>} - Array of yearly population points
   */
  async computeYearlyPopulationTimeSeries(geometry, baseYear = 2020) {
    try {
      // Available population data years in GPW v4.11
      const availableYears = [2000, 2005, 2010, 2015, 2020, 2025];
      
      console.log(`üìà Computing population time series for available years: ${availableYears.join(', ')}`);
      
      const timeSeries = [];
      
      // Process each available year
      for (const year of availableYears) {
        console.log(`üìÖ Processing population year ${year}...`);
        
        try {
          // GPW provides specific year data
          const startDate = `${year}-01-01`;
          const endDate = `${year}-12-31`;
          
          // NASA SEDAC Gridded Population of World (GPW) v4.11
          const populationCollection = ee.ImageCollection('CIESIN/GPWv411/GPW_Population_Density');
          
          const populationDensity = populationCollection
            .filterDate(startDate, endDate)
            .first()
            .select('population_density')
            .clip(geometry);
          
          // Check if data exists for this year
          const hasData = await new Promise((resolve, reject) => {
            populationDensity.getInfo((info, error) => {
              if (error) {
                console.warn(`‚ö†Ô∏è Error checking population data for year ${year}:`, error.message);
                resolve(false);
              } else {
                resolve(info !== null);
              }
            });
          });
          
          if (!hasData) {
            // No data available for this year
            timeSeries.push({
              year: year,
              meanDensity: null,
              totalPopulation: null,
              hasData: false
            });
            console.log(`‚ùå No population data available for year ${year}`);
            continue;
          }
          
          // Calculate mean population density and total population
          const reduceCfg = { 
            reducer: ee.Reducer.mean().combine(ee.Reducer.sum(), '', true),
            geometry: geometry,
            scale: 1000, // GPW ~1km resolution
            maxPixels: 1e9 
          };
          
          const yearResult = await new Promise((resolve, reject) => {
            populationDensity.reduceRegion(reduceCfg).getInfo((result, error) => {
              if (error) reject(error);
              else resolve(result);
            });
          });
          
          const meanDensity = yearResult.population_density_mean;
          const totalPopulation = yearResult.population_density_sum;
          
          if (meanDensity !== null && !isNaN(meanDensity)) {
            // Calculate area to get proper total population estimate
            const areaResult = await new Promise((resolve, reject) => {
              geometry.area(1).getInfo((area, error) => {
                if (error) reject(error);
                else resolve(area / 1e6); // Convert to km¬≤
              });
            });
            
            const estimatedTotalPopulation = meanDensity * areaResult;
            
            timeSeries.push({
              year: year,
              meanDensity: parseFloat(meanDensity.toFixed(2)),
              totalPopulation: parseFloat(estimatedTotalPopulation.toFixed(0)),
              hasData: true
            });
            console.log(`‚úÖ Year ${year}: ${meanDensity.toFixed(2)} people/km¬≤ (Total: ${estimatedTotalPopulation.toFixed(0)})`);
          } else {
            // Data exists but computation failed
            timeSeries.push({
              year: year,
              meanDensity: null,
              totalPopulation: null,
              hasData: false
            });
            console.log(`‚ö†Ô∏è Year ${year}: No valid pixels after processing`);
          }
          
        } catch (yearError) {
          console.warn(`‚ö†Ô∏è Error processing population year ${year}:`, yearError.message);
          // Add null entry for failed year
          timeSeries.push({
            year: year,
            meanDensity: null,
            totalPopulation: null,
            hasData: false
          });
        }
      }
      
      console.log(`üìà Population time series computation complete: ${timeSeries.filter(p => p.hasData).length}/${timeSeries.length} years with data`);
      return timeSeries;
      
    } catch (error) {
      console.error('‚ùå Error computing population time series:', error);
      // Return empty array on failure to not break main response
      return [];
    }
  }

  /**
   * Get basic population data for risk assessment (lightweight version)
   * @param {Object} bounds - Geographic bounds {west, south, east, north}
   * @param {number} year - Year for population data (2000, 2005, 2010, 2015, 2020)
   * @returns {Promise<Object>} Basic population statistics
   */
  async getBasicPopulationData(bounds, year = 2020) {
    await this.initialize();

    try {
      console.log('üë• Processing basic population data for risk assessment...');
      
      // --- AOI (Area of Interest) ---
      const geometry = ee.Geometry.Rectangle([bounds.west, bounds.south, bounds.east, bounds.north]);
      
      // Calculate area in km¬≤
      const areaMeters = geometry.area();
      const areaKm2 = areaMeters.divide(1e6);

      // --- NASA SEDAC Gridded Population of World (GPW) v4.11 ---
      const populationCollection = ee.ImageCollection('CIESIN/GPWv411/GPW_Population_Density');
      
      // Filter by year - GPW provides data for 2000, 2005, 2010, 2015, 2020
      const startYear = year.toString() + '-01-01';
      const endYear = year.toString() + '-12-31';
      
      const populationDensity = populationCollection
        .filterDate(startYear, endYear)
        .first()
        .select('population_density')
        .clip(geometry);

      // Check if data exists
      const imageCheck = await new Promise((resolve, reject) => {
        populationDensity.getInfo((info, error) => {
          if (error || !info) {
            reject(new Error(`No population data available for year ${year} in this area`));
          } else {
            resolve(info);
          }
        });
      });

      console.log(`üìä Computing basic population statistics for year ${year}`);

      // --- Calculate basic population statistics ---
      const reduceCfg = { 
        reducer: ee.Reducer.mean().combine(
          ee.Reducer.minMax(), '', true
        ).combine(
          ee.Reducer.sum(), '', true
        ), 
        geometry, 
        scale: 1000,  // ~1km resolution
        maxPixels: 1e6  // Lower limit for faster processing
      };
      
      const [populationStats, areaResult] = await Promise.all([
        new Promise((resolve, reject) => {
          populationDensity.reduceRegion(reduceCfg).getInfo((result, error) => {
            if (error) {
              reject(error);
            } else {
              resolve(result || {});
            }
          });
        }),
        new Promise((resolve, reject) => {
          areaKm2.getInfo((result, error) => {
            if (error) {
              reject(error);
            } else {
              resolve(result || 0);
            }
          });
        })
      ]);

      // Extract population statistics
      const meanDensity = populationStats.population_density_mean || 0;
      const minDensity = populationStats.population_density_min || 0;
      const maxDensity = populationStats.population_density_max || 0;
      const totalPopulation = populationStats.population_density_sum || 0;

      console.log(`‚úÖ Basic population data processed successfully`);
      console.log(`üìä Total Population: ${Math.round(totalPopulation).toLocaleString()}`);
      console.log(`üìä Average Density: ${Math.round(meanDensity)} people/km¬≤`);
      console.log(`üìä Area: ${Math.round(areaResult * 100) / 100} km¬≤`);

      return {
        success: true,
        data: {
          population_sum: Math.round(totalPopulation),
          population_density_mean: Math.round(meanDensity * 100) / 100,
          population_density_min: Math.round(minDensity * 100) / 100,
          population_density_max: Math.round(maxDensity * 100) / 100,
          totalArea: Math.round(areaResult * 100) / 100,
          year: year,
          bounds: bounds,
          timestamp: new Date().toISOString()
        }
      };

    } catch (error) {
      console.error('‚ùå Error in basic population data processing:', error);
      throw new Error(`Failed to process basic population data: ${error.message}`);
    }
  }

  /**
   * Get Energy Access Proxy data using built-up + nighttime lights analysis
   * @param {Object} bounds - Bounding box { west, south, east, north }
   * @param {number} year - Year for analysis (default: 2023)
   * @returns {Promise<Object>} - Energy access proxy data with PNG overlay
   */
  async getEnergyAccessProxy(bounds, year = 2024) {
    await this.initialize();

    const geometry = ee.Geometry.Rectangle([bounds.west, bounds.south, bounds.east, bounds.north]);
    const analysisScale = 250; // meters
    const crs = 'EPSG:4326';   // only for viz if needed

    console.log(`üîã Processing Energy Access Proxy for bounds:`, bounds, `Year: ${year}`);

    // Helper: area reducer (m¬≤) at analysisScale
    const areaReducer = (imgMask) =>
      ee.Image.pixelArea()
        .updateMask(imgMask)
        .reduceRegion({
          reducer: ee.Reducer.sum(),
          geometry,
          scale: analysisScale,
          maxPixels: 1e13,
          tileScale: 4
        })
        .getNumber('area');

      // --- Core Datasets (no population) ---
      
      // Nighttime lights (VIIRS annual V22) with fallback for year gaps
      const ntlIc = ee.ImageCollection('NOAA/VIIRS/DNB/ANNUAL_V22')
        .filterDate(`${year}-01-01`, `${year + 1}-01-01`)
        .select('median');

      const ntlIcFallback = ee.ImageCollection('NOAA/VIIRS/DNB/ANNUAL_V22')
        .filterDate(`${year - 1}-01-01`, `${year}-01-01`)
        .select('median');

      const ntlIcFallback2 = ee.ImageCollection('NOAA/VIIRS/DNB/ANNUAL_V22')
        .filterDate(`${year - 2}-01-01`, `${year - 1}-01-01`)
        .select('median');

      // Prefer requested year; if empty, fall back one or two years
      const ntlChosen = ee.ImageCollection(ee.Algorithms.If(
        ntlIc.size().gt(0), ntlIc,
        ee.Algorithms.If(
          ntlIcFallback.size().gt(0), ntlIcFallback,
          ntlIcFallback2
        )
      ));

      const ntl = ntlChosen.mosaic().rename('ntl').clip(geometry)
        .reproject({ crs: crs, scale: analysisScale });

      // Validate nighttime lights availability
      const ntlCount = await new Promise((resolve, reject) => {
        ntlChosen.size().getInfo((v, e) => e ? reject(e) : resolve(v));
      });
      
      if (!ntlCount) {
        throw new Error(`No VIIRS annual lights available for ${year}, ${year-1}, or ${year-2}. Try a different year or region.`);
      }
      
      console.log(`üì° Using VIIRS nighttime lights data (${ntlCount} images available)`);

      // Built surface (2020)
      const builtSurface = ee.Image('JRC/GHSL/P2023A/GHS_BUILT_S/2020')
        .select('built_surface')
        .clip(geometry)
        .reproject({ crs: crs, scale: analysisScale });

      // Built volume (2020)  
      const builtVolume = ee.Image('JRC/GHSL/P2023A/GHS_BUILT_V/2020')
        .select('built_volume_total')
        .clip(geometry)
        .reproject({ crs: crs, scale: analysisScale });

      // Built fraction with lower threshold to avoid over-flagging
      const builtFrac = builtSurface.divide(pixelArea).clamp(0, 1).rename('builtFrac');
      const builtMask = builtFrac.gt(0.05); // 5% built threshold instead of 30%
      
      // Add land mask to avoid water skew (important for coastal cities)
      const water = ee.Image('JRC/GSW1_4/GlobalSurfaceWater').select('occurrence');
      const landMask = water.lt(50); // seen water <50% of years
      const analysisMask = builtMask.and(landMask);

      console.log('üìä Datasets loaded, computing robust indicators...');

      // --- Robust rescale helper function with degenerate percentile handling ---
      const robustRescale01 = (img, geom, scale, pLow = 10, pHigh = 90) => {
        const band = img.bandNames().get(0);
        const stats = img.reduceRegion({
          reducer: ee.Reducer.percentile([pLow, pHigh]),
          geometry: geom,
          scale: scale,
          maxPixels: 1e13,
          tileScale: 4  // Use tileScale instead of bestEffort
        });
        const lo = ee.Number(stats.get(ee.String(band).cat(`_p${pLow}`)));
        const hi = ee.Number(stats.get(ee.String(band).cat(`_p${pHigh}`)));
        const rng = hi.subtract(lo);
        
        // If percentiles collapse, fall back to global min/max within mask
        const safeRng = ee.Algorithms.If(
          rng.lte(0),
          img.reduceRegion({
            reducer: ee.Reducer.minMax(),
            geometry: geom,
            scale: scale,
            maxPixels: 1e13,
            tileScale: 4
          }).getNumber(ee.String(band).cat('_max')).subtract(
            ee.Number(
              img.reduceRegion({
                reducer: ee.Reducer.minMax(),
                geometry: geom,
                scale: scale,
                maxPixels: 1e13,
                tileScale: 4
              }).get(ee.String(band).cat('_min'))
            )
          ).max(1e-6),
          rng
        );
        return img.subtract(lo).divide(ee.Number(safeRng)).clamp(0, 1);
      };

      // --- Normalize lights with log transform ---
      // Log transform to handle heavy-tailed distribution
      const ntlLog = ntl.add(1).log(); // log1p to handle zeros
      const ntlLogScaled = robustRescale01(ntlLog.updateMask(analysisMask), geometry, analysisScale, 10, 99);
      // Convert to lack-of-light (bright = 0, dark = 1)
      const lightsLack = ee.Image(1).subtract(ntlLogScaled);

      // --- Built index from surface + volume ---
      const builtSurfaceScaled = robustRescale01(builtSurface.updateMask(analysisMask), geometry, analysisScale, 10, 90);
      const builtVolumeScaled = robustRescale01(builtVolume.updateMask(analysisMask), geometry, analysisScale, 10, 90);
      // Blend surface and volume, soften with sqrt to reduce extremes
      const builtIndex = builtSurfaceScaled.multiply(0.6).add(builtVolumeScaled.multiply(0.4)).sqrt();

      console.log('‚ö° Computing improved Energy Access Proxy...');

      // --- New EAP (no problematic ratios) ---
      // Where built is high AND lights are lacking
      const eap = builtIndex.multiply(lightsLack).rename('EAP').updateMask(analysisMask);

      // --- Smooth to reduce salt-and-pepper effect ---
      const kernel = ee.Kernel.square({ radius: 1 }); // 3x3 kernel
      const eapSm = eap.focal_mean({ kernel: kernel, iterations: 1 });
      
      // --- Coverage validation ---
      const analyzedPx = eapSm.updateMask(analysisMask).reduceRegion({
        reducer: ee.Reducer.count(),
        geometry: geometry,
        scale: analysisScale,
        maxPixels: 1e13,
        tileScale: 4
      });
      
      const totalPx = ee.Image(1).reduceRegion({
        reducer: ee.Reducer.count(),
        geometry: geometry,
        scale: analysisScale,
        maxPixels: 1e13,
        tileScale: 4
      });
      
      const [anCt, totCt] = await Promise.all([
        new Promise((res, rej) => analyzedPx.getInfo((v, e) => e ? rej(e) : res(v))),
        new Promise((res, rej) => totalPx.getInfo((v, e) => e ? rej(e) : res(v)))
      ]);
      
      const coverage = anCt.count / Math.max(1, totCt.count);
      if (coverage < 0.3) {
        throw new Error(`Too little analyzable land/built area (${(coverage * 100).toFixed(1)}%). Refine AOI or relax masks.`);
      }
      
      console.log(`üìä Analysis coverage: ${(coverage * 100).toFixed(1)}% of total area`);
      

      // --- Classify by quantiles with proper degenerate handling ---
      // Try wider percentile spread first for better stability
      const qs = eapSm.reduceRegion({
        reducer: ee.Reducer.percentile([10, 30, 50, 70, 90]),
        geometry: geometry,
        scale: analysisScale,
        maxPixels: 1e13,
        tileScale: 4
      });
      
      const q20 = ee.Number(qs.get('EAP_p10'));
      const q40 = ee.Number(qs.get('EAP_p30'));
      const q60 = ee.Number(qs.get('EAP_p50'));
      const q80 = ee.Number(qs.get('EAP_p70'));
      
      // Check for degenerate percentiles and use equal-width bins as fallback
      const degenerate = q80.subtract(q20).lte(1e-6);
      
      // If still degenerate, final fallback: use global min/max to make equal-width bins
      const eMinMax = eapSm.reduceRegion({
        reducer: ee.Reducer.minMax(),
        geometry: geometry,
        scale: analysisScale,
        maxPixels: 1e13,
        tileScale: 4
      });
      const eMin = ee.Number(eMinMax.get('EAP_min'));
      const eMax = ee.Number(eMinMax.get('EAP_max'));
      const width = eMax.subtract(eMin).divide(5);
      const fq20 = eMin.add(width);
      const fq40 = eMin.add(width.multiply(2));
      const fq60 = eMin.add(width.multiply(3));
      const fq80 = eMin.add(width.multiply(4));
      
      // Choose between quantiles or equal-width cuts
      const finalQ20 = ee.Number(ee.Algorithms.If(degenerate, fq20, q20));
      const finalQ40 = ee.Number(ee.Algorithms.If(degenerate, fq40, q40));
      const finalQ60 = ee.Number(ee.Algorithms.If(degenerate, fq60, q60));
      const finalQ80 = ee.Number(ee.Algorithms.If(degenerate, fq80, q80));

      // Severity 0-4 using stabilized quantiles
      const severity = eapSm.expression(
        '(e <= q20) ? 0 : (e <= q40) ? 1 : (e <= q60) ? 2 : (e <= q80) ? 3 : 4',
        { e: eapSm, q20: finalQ20, q40: finalQ40, q60: finalQ60, q80: finalQ80 }
      ).rename('severity');

      // --- Critical areas as top 20% by EAP ---
      const criticalAreas = eapSm.gte(finalQ80);
      
      // --- Absolute classification for cross-city comparison ---
      // Define "energy-deprived built" as: EAP > 0.6 and ntlLogScaled < 0.3 and builtIndex > 0.4
      const deprived = eapSm.gt(0.6)
        .and(ntlLogScaled.lt(0.3))
        .and(builtIndex.gt(0.4));
      
      const deprivedShare = await new Promise((res, rej) =>
        deprived.selfMask().reduceRegion({
          reducer: ee.Reducer.mean(),
          geometry: geometry,
          scale: analysisScale,
          maxPixels: 1e13,
          tileScale: 4
        }).getInfo((r, e) => e ? rej(e) : res(r.EAP || 0))
      );
      
      console.log(`üèóÔ∏è Energy-deprived built areas: ${(deprivedShare * 100).toFixed(1)}% (absolute metric)`);

      console.log('üñºÔ∏è Generating visualization...');

      // --- Visualization & export URL ---
      const eapVis = {
        min: 0, max: 1,
        palette: ['#1a9850', '#66bd63', '#a6d96a', '#ffffbf', '#fdae61', '#f46d43', '#d73027']
      };

      const severityVis = {
        min: 0, max: 4,
        palette: ['#ffffff', '#2166ac', '#fee08b', '#f46d43', '#a50026']
      };

      // Create visualization layer (using smoothed EAP)
      const visImage = eapSm.visualize(eapVis);

      // Get PNG URL
      const imageUrl = await new Promise((resolve, reject) => {
        visImage.getThumbURL({
          region: geometry,
          dimensions: 1024,
          format: 'png'
        }, (url, error) => {
          if (error) reject(error);
          else resolve(url);
        });
      });

      console.log('üìà Computing area-weighted statistics...');

      // --- Calculate total geometry area ---
      const totalAreaKm2 = await new Promise((resolve, reject) => {
        geometry.area().getInfo((result, error) => {
          if (error) reject(error);
          else resolve((result || 0) / 1e6); // Convert from m¬≤ to km¬≤
        });
      });

      // --- Define class masks (disjoint by construction) ---
      const criticalMask = eapSm.gte(finalQ80);
      const nearCriticalMask = eapSm.gte(finalQ60).and(eapSm.lt(finalQ80));

      // --- Helper function to get area safely ---
      const pxArea = ee.Image.pixelArea(); // m¬≤
      const areaKm2 = (imgMask) => {
        const areaImg = pxArea.updateMask(imgMask).rename('area');
        return ee.Number(
          areaImg.reduceRegion({
            reducer: ee.Reducer.sum(),
            geometry: geometry,
            scale: analysisScale,
            maxPixels: 1e13,
            tileScale: 4
          }).get('area')
        ).divide(1e6); // m¬≤ -> km¬≤
      };

      // --- Compute analyzable area and class areas ---
      const analyzableKm2Ee = areaKm2(analysisMask);
      const criticalKm2Ee = areaKm2(criticalMask.and(analysisMask));
      const nearCriticalKm2Ee = areaKm2(nearCriticalMask.and(analysisMask));

      // Get values as numbers
      const [analyzableAreaKm2, criticalAreaKm2, nearCriticalAreaKm2] = await Promise.all([
        new Promise((resolve, reject) => {
          analyzableKm2Ee.getInfo((result, error) => {
            if (error) reject(error);
            else resolve(result || 0);
          });
        }),
        new Promise((resolve, reject) => {
          criticalKm2Ee.getInfo((result, error) => {
            if (error) reject(error);
            else resolve(result || 0);
          });
        }),
        new Promise((resolve, reject) => {
          nearCriticalKm2Ee.getInfo((result, error) => {
            if (error) reject(error);
            else resolve(result || 0);
          });
        })
      ]);

      // --- Calculate percentages relative to analyzable area ---
      const criticalAreaPct = parseFloat(((criticalAreaKm2 / Math.max(analyzableAreaKm2, 0.001)) * 100).toFixed(2));
      const nearCriticalAreaPct = parseFloat(((nearCriticalAreaKm2 / Math.max(analyzableAreaKm2, 0.001)) * 100).toFixed(2));
      const normalAreaKm2 = parseFloat((analyzableAreaKm2 - criticalAreaKm2 - nearCriticalAreaKm2).toFixed(2));
      const normalAreaPct = parseFloat((100 - criticalAreaPct - nearCriticalAreaPct).toFixed(2));

      // Round the area values
      const criticalAreaKm2Final = parseFloat(criticalAreaKm2.toFixed(2));
      const nearCriticalAreaKm2Final = parseFloat(nearCriticalAreaKm2.toFixed(2));
      const analyzableAreaKm2Final = parseFloat(analyzableAreaKm2.toFixed(2));

      console.log(`ÔøΩ Total area: ${totalAreaKm2.toFixed(2)} km¬≤ | Analyzable: ${analyzableAreaKm2Final} km¬≤`);
      console.log(`ÔøΩüî¥ Critical areas: ${criticalAreaKm2Final} km¬≤ (${criticalAreaPct}%)`);
      console.log(`üü† Near-critical areas: ${nearCriticalAreaKm2Final} km¬≤ (${nearCriticalAreaPct}%)`);
      console.log(`üü¢ Normal areas: ${normalAreaKm2} km¬≤ (${normalAreaPct}%)`);

      // Severity histogram using integer values to avoid decimals
      const severityInt = severity.toInt8(); // ensure integer band
      const severityStats = await new Promise((resolve, reject) => {
        severityInt.updateMask(analysisMask).reduceRegion({
          reducer: ee.Reducer.frequencyHistogram(),
          geometry: geometry,
          scale: analysisScale,
          maxPixels: 1e13,
          tileScale: 4
        }).getInfo((result, error) => {
          if (error) reject(error);
          else resolve(result.severity || {});
        });
      });

      // Convert to standard format
      const severityHistogram = {
        s0: severityStats['0'] || 0,
        s1: severityStats['1'] || 0,
        s2: severityStats['2'] || 0,
        s3: severityStats['3'] || 0,
        s4: severityStats['4'] || 0
      };

      console.log('‚úÖ Energy Access Proxy analysis complete');

      // Return object mirroring the structure expected by frontend services
      return {
        success: true,
        layerType: 'energy',
        imageUrl: imageUrl,
        overlayBounds: {
          southwest: { lat: bounds.south, lng: bounds.west },
          northeast: { lat: bounds.north, lng: bounds.east }
        },
        attribution: 'VIIRS V22 (NOAA), GHSL 2023A (JRC)',
        timestamp: new Date().toISOString(),
        statistics: {
          totalAreaKm2: parseFloat(totalAreaKm2.toFixed(2)),
          analyzableAreaKm2: analyzableAreaKm2Final,
          criticalAreaPct: criticalAreaPct,
          criticalAreaKm2: criticalAreaKm2Final,
          nearCriticalAreaPct: nearCriticalAreaPct,
          nearCriticalAreaKm2: nearCriticalAreaKm2Final,
          // Absolute metric for cross-city comparison
          energyDeprivedPct: parseFloat((deprivedShare * 100).toFixed(2)),
          energyDeprivedKm2: parseFloat((analyzableAreaKm2Final * deprivedShare).toFixed(2)),
          // Coverage and data quality
          analysisCoverage: parseFloat((coverage * 100).toFixed(1)),
          dataYear: ntlCount > 0 ? year : `${year} (fallback used)`,
          // Additional calculated fields for enhanced statistics
          totalCriticalAndNearKm2: parseFloat((criticalAreaKm2Final + nearCriticalAreaKm2Final).toFixed(2)),
          totalCriticalAndNearPct: parseFloat(((criticalAreaPct + nearCriticalAreaPct)).toFixed(2)),
          normalAreasKm2: normalAreaKm2,
          normalAreasPct: normalAreaPct,
          severityHistogram: severityHistogram,
          // Area breakdown by severity levels
          areaBreakdown: {
            excellent: {
              count: severityHistogram.s0 || 0,
              percentage: parseFloat((((severityHistogram.s0 || 0) / Object.values(severityHistogram).reduce((a, b) => a + (b || 0), 0)) * 100).toFixed(1))
            },
            good: {
              count: severityHistogram.s1 || 0,
              percentage: parseFloat((((severityHistogram.s1 || 0) / Object.values(severityHistogram).reduce((a, b) => a + (b || 0), 0)) * 100).toFixed(1))
            },
            moderate: {
              count: severityHistogram.s2 || 0,
              percentage: parseFloat((((severityHistogram.s2 || 0) / Object.values(severityHistogram).reduce((a, b) => a + (b || 0), 0)) * 100).toFixed(1))
            },
            concerning: {
              count: severityHistogram.s3 || 0,
              percentage: parseFloat((((severityHistogram.s3 || 0) / Object.values(severityHistogram).reduce((a, b) => a + (b || 0), 0)) * 100).toFixed(1))
            },
            critical: {
              count: severityHistogram.s4 || 0,
              percentage: parseFloat((((severityHistogram.s4 || 0) / Object.values(severityHistogram).reduce((a, b) => a + (b || 0), 0)) * 100).toFixed(1))
            }
          }
        },
        metadata: {
          dataSource: 'VIIRS+GHSL+GSW',
          resolution: '250m',
          yearPeriod: `${year}`,
          algorithm: 'Stabilized Energy Access Proxy v2.0',
          method: 'Quantile-based classification with degenerate handling and water masking',
          improvements: [
            'Year fallback for VIIRS gaps',
            'Degenerate percentile detection',
            'Water mask for coastal accuracy', 
            'TileScale optimization',
            'Coverage validation',
            'Cross-city absolute metrics'
          ],
          qualityMetrics: {
            coveragePercent: parseFloat((coverage * 100).toFixed(1)),
            ntlImagesUsed: ntlCount,
            degeneratePercentiles: false // Could be enhanced to report actual detection
          }
        }
      };

    } catch (error) {
      console.error('‚ùå Error in Energy Access Proxy analysis:', error);
      
      if (error.message.includes('User memory limit exceeded')) {
        throw new Error('Area too large for processing. Please try a smaller region.');
      } else if (error.message.includes('Computation timed out')) {
        throw new Error('Processing timed out. Please try a smaller area.');
      } else {
        throw new Error(`Failed to process energy access data: ${error.message}`);
      }
    }
  }

  /**
   * Get energy access data for predefined city bounds
   * @param {string} cityName - Name of the city
   * @param {number} year - Year for analysis (default: 2023)
   * @returns {Promise<Object>} - Energy access data for the city
   */
  async getCityEnergyData(cityName, year = 2024) {
    const cityBounds = this.getCityBounds(cityName);
    if (!cityBounds) {
      throw new Error(`City "${cityName}" not found or not supported`);
    }

    return await this.getEnergyAccessProxy(cityBounds, year);
  }

  /**
   * Get supported cities list
   * @returns {Array} - List of supported city names
   */
  getSupportedCities() {
    return ['New York', 'Los Angeles', 'Chicago', 'Houston', 'Phoenix', 'Philadelphia'];
  }
}

module.exports = new GEEService();